/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.johnsnowlabs.nlp.annotators.parser.dl

import com.johnsnowlabs.ml.tensorflow.{TensorResources, TensorflowEmbeddingLookup, TensorflowWrapper}
import com.johnsnowlabs.nlp.AnnotatorType.{DEPENDENCY, DOCUMENT, TOKEN}
import com.johnsnowlabs.nlp.serialization.MapFeature
import com.johnsnowlabs.nlp.{Annotation, AnnotatorModel, AnnotatorType, HasSimpleAnnotate}
import org.apache.spark.ml.util.Identifiable
import org.tensorflow.op.Scope
import org.tensorflow.op.core.Constant
import org.tensorflow.types.TFloat32
import org.tensorflow.{EagerSession, Operand, SavedModelBundle, Tensor}

class DependencyParserDLModel(override val uid: String) extends AnnotatorModel[DependencyParserDLModel]
  with HasSimpleAnnotate[DependencyParserDLModel] {

  def this() = this(Identifiable.randomUID(DEPENDENCY))

  protected val vocabulary: MapFeature[String, Int] = new MapFeature[String, Int](this, "vocabulary to lookup embeddings based on word id")

  def setVocabulary(value: Map[String, Int]): this.type = set(vocabulary, value)

  private lazy val vocabularySize = $$(vocabulary).size

  private val embeddingsSize = 100
  private val sampleSize = 1

  /**
    * takes a document and annotations and produces new annotations of this annotator's annotation type
    *
    * @param annotations Annotations that correspond to inputAnnotationCols generated by previous annotators if any
    * @return any number of annotations processed for every input annotation. Not necessary one to one relationship
    */
  override def annotate(annotations: Seq[Annotation]): Seq[Annotation] = {
    val session = EagerSession.create
    val scope = new Scope(session)

    val embeddings = new TensorflowEmbeddingLookup(embeddingsSize, vocabularySize, scope)
    val embeddingsTable = embeddings.initializeTable()

    val tokens = annotations
      .filter(_.annotatorType == AnnotatorType.TOKEN)
      .toArray

    val sentenceEmbeddings: Array[Operand[TFloat32]] = tokens.map{ token =>
      val wordId: Int = $$(vocabulary).getOrElse(token.result, 0)
      Constant.create(scope, embeddings.lookup(embeddingsTable, Array(wordId)))
    }

    val biLstmInputs = getBiLstmInput(sentenceEmbeddings, scope)

    Seq()
  }

  def getBiLstmInput(sentenceEmbeddings: Array[Operand[TFloat32]], scope: Scope) = {
    val timeSteps = sentenceEmbeddings.length
    val reverseSentenceEmbeddings: Array[Operand[TFloat32]] = sentenceEmbeddings.map{ wordEmbeddings =>
      Constant.create(scope, TensorResources.reverseTensor(scope, wordEmbeddings, 1).asInstanceOf[Tensor[TFloat32]])
    }
    val concatSentenceEmbeddings = TensorResources.concatTensors(scope, sentenceEmbeddings, 0)
    val concatReverseSentenceEmbeddings = TensorResources.concatTensors(scope, reverseSentenceEmbeddings, 0)

    val shape = Array(timeSteps, sampleSize, embeddingsSize)

    val forwardVector = TensorResources.reshapeTensor(scope, Constant.create(scope, concatSentenceEmbeddings), shape)
    val backwardVector = TensorResources.reshapeTensor(scope, Constant.create(scope, concatReverseSentenceEmbeddings), shape)
  }

  def restoreLstmWeights(): Map[String, Tensor[TFloat32]] = {
    val tags: Array[String] = Array(SavedModelBundle.DEFAULT_TAG)
    val modelPath: String = "src/test/resources/tensorflow/models/dependency-parser/bi-lstm/"
    val model: SavedModelBundle = TensorflowWrapper.withSafeSavedModelBundleLoader(tags = tags, savedModelDir = modelPath)
    val weightsVariables = List("w_first_lstm", "wig_first_lstm", "wfg_first_lstm", "wog_first_lstm")

    val firstLstmWeights: Map[String, Tensor[TFloat32]] = weightsVariables.map{ weightVariable =>
      val variableName = "bi_lstm_model/FirstBlockLSTMModule/" + weightVariable + "/Read/ReadVariableOp"
      val tensor = TensorflowWrapper.restoreVariable(model, modelPath, variableName)
      (weightVariable, tensor.expect(TFloat32.DTYPE))
    }.toMap

    firstLstmWeights

  }

  /** Annotator reference id. Used to identify elements in metadata or to refer to this annotator type */
  override val inputAnnotatorTypes: Array[String] = Array[String](DOCUMENT, TOKEN)
  override val outputAnnotatorType: AnnotatorType = DEPENDENCY

}
