package com.johnsnowlabs.nlp.annotators

import ai.djl.Model
import ai.djl.ndarray.NDList
import ai.djl.pytorch.engine.PtModel
import ai.djl.translate.{Batchifier, Translator, TranslatorContext}
import com.johnsnowlabs.ml.pytorch.{PytorchLinearRegression, PytorchWrapper}
import com.johnsnowlabs.nlp.AnnotatorType.{CHUNK, TOKEN}
import com.johnsnowlabs.nlp.util.io.ResourceHelper
import com.johnsnowlabs.nlp.{Annotation, AnnotatorModel, HasSimpleAnnotate}
import org.apache.spark.broadcast.Broadcast
import org.apache.spark.ml.util.Identifiable
import org.apache.spark.sql.SparkSession

import java.io.ByteArrayInputStream

class LinearRegression(override val uid: String) extends AnnotatorModel[LinearRegression]
  with HasSimpleAnnotate[LinearRegression] {

  override val outputAnnotatorType: AnnotatorType = CHUNK
  /** Annotator reference id. Used to identify elements in metadata or to refer to this annotator type */
  override val inputAnnotatorTypes: Array[String] = Array(TOKEN)

  def this() = this(Identifiable.randomUID("LINEAR_REGRESSION"))

  private var pyTorchModel: Option[Broadcast[PytorchLinearRegression]] = None

  def setPytorchModelIfNotSet(spark: SparkSession, pytorchWrapper: PytorchWrapper): LinearRegression = {
    if (pyTorchModel.isEmpty) {
      pyTorchModel = Some(spark.sparkContext.broadcast(new PytorchLinearRegression(pytorchWrapper)))
    }
    this
  }

  /**
   * takes a document and annotations and produces new annotations of this annotator's annotation type
   *
   * @param annotations Annotations that correspond to inputAnnotationCols generated by previous annotators if any
   * @return any number of annotations processed for every input annotation. Not necessary one to one relationship
   */
  override def annotate(annotations: Seq[Annotation]): Seq[Annotation] = {

    val numericRepresentation = annotations.map { annotation =>
      annotation.result.toCharArray.map(character => character.toInt).mkString("")
    }

    val linearRegression = numericRepresentation.map{ number =>
      val output = pyTorchModel.get.value.inferFromBytes(number.toFloat)
      Annotation(CHUNK, 0, 0, output.toString, Map())
    }

    linearRegression

  }

}

trait ReadLinearRegressionPyTorchModel {

  def loadSavedModel(pyTorchModelPath: String, spark: SparkSession): LinearRegression = {
    val pytorchWrapper = PytorchWrapper(pyTorchModelPath)
    new LinearRegression().setPytorchModelIfNotSet(spark, pytorchWrapper)
  }

}

object LinearRegression extends ReadLinearRegressionPyTorchModel