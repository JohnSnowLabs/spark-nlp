package com.johnsnowlabs.nlp.annotators

import ai.djl.Model
import ai.djl.ndarray.NDList
import ai.djl.pytorch.engine.PtModel
import ai.djl.translate.{Batchifier, Translator, TranslatorContext}
import com.johnsnowlabs.ml.pytorch.PytorchWrapper
import com.johnsnowlabs.nlp.AnnotatorType.{CHUNK, TOKEN}
import com.johnsnowlabs.nlp.util.io.ResourceHelper
import com.johnsnowlabs.nlp.{Annotation, AnnotatorModel, HasSimpleAnnotate}
import org.apache.spark.broadcast.Broadcast
import org.apache.spark.ml.util.Identifiable
import org.apache.spark.sql.SparkSession

import java.io.ByteArrayInputStream

class LinearRegression(override val uid: String) extends AnnotatorModel[LinearRegression]
  with HasSimpleAnnotate[LinearRegression] {

  override val outputAnnotatorType: AnnotatorType = CHUNK
  /** Annotator reference id. Used to identify elements in metadata or to refer to this annotator type */
  override val inputAnnotatorTypes: Array[String] = Array(TOKEN)

  def this() = this(Identifiable.randomUID("LINEAR_REGRESSION"))

  private var pyTorchModelBroadcast: Option[Broadcast[PtModel]] = None

  private var pyTorchModel: Option[Broadcast[PytorchWrapper]] = None

  private var predictor: Option[Broadcast[ai.djl.inference.Predictor[Float, Float]]] = None

  def setBroadcastModelIfNotSet(spark: SparkSession, pyTorchModel: PtModel): LinearRegression = {
    if (pyTorchModelBroadcast.isEmpty) {
      println("************* Before broadcasting")
      pyTorchModelBroadcast = Some(spark.sparkContext.broadcast(pyTorchModel))
    }
    this
  }

  def setModelStreamIfNotSet(spark: SparkSession, sourceBytes: Array[Byte]): LinearRegression = {
    pyTorchModel = Some(spark.sparkContext.broadcast(new PytorchWrapper(Some(sourceBytes))))
    this
  }

  /**
   * takes a document and annotations and produces new annotations of this annotator's annotation type
   *
   * @param annotations Annotations that correspond to inputAnnotationCols generated by previous annotators if any
   * @return any number of annotations processed for every input annotation. Not necessary one to one relationship
   */
  override def annotate(annotations: Seq[Annotation]): Seq[Annotation] = {

    val numericRepresentation = annotations.map { annotation =>
      annotation.result.toCharArray.map(character => character.toInt).mkString("")
    }

    val linearRegression = numericRepresentation.map{ number =>
      val output = pyTorchModel.get.value.inferFromBytes(number.toFloat)
      Annotation(CHUNK, 0, 0, output.toString, Map())
    }

    linearRegression

  }

}

trait ReadLinearRegressionPyTorchModel {

  def loadSavedModel(pyTorchModelPath: String, spark: SparkSession): LinearRegression = {

    val pyTorchModel = PytorchWrapper.readBytes(pyTorchModelPath)
    println("************* Before returning loadSavedModel.setModelIfNotSet")
    new LinearRegression().setModelStreamIfNotSet(spark, pyTorchModel)
  }

}

object LinearRegression extends ReadLinearRegressionPyTorchModel