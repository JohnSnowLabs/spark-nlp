
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>sparknlp.base &#8212; Spark NLP 3.3.4 documentation</title>
    
  <link href="../../static/css/theme.css" rel="stylesheet">
  <link href="../../static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../../static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="../../static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../static/css/blank.css" />
    <link rel="stylesheet" type="text/css" href="../../static/css/custom.css" />
    
  <link rel="preload" as="script" href="../../static/js/index.be7d3bbb2ef33a8344ce.js">

    <script data-url_root="../../" id="documentation_options" src="../../static/documentation_options.js"></script>
    <script src="../../static/jquery.js"></script>
    <script src="../../static/underscore.js"></script>
    <script src="../../static/doctools.js"></script>
    <script src="../../static/toggleprompt.js"></script>
    <link rel="shortcut icon" href="../../static/fav.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="container-xl">

  <div id="navbar-start">
    
    

<a class="navbar-brand" href="../../index.html">
  <img src="../../static/logo.png" class="logo" alt="logo">
</a>


    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../getting_started/index.html">
  Getting Started
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../user_guide/index.html">
  User Guide
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../third_party/index.html">
  Third Party Projects
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../reference/index.html">
  API Reference
 </a>
</li>

    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
            
            <!-- Only show if we have sidebars configured, else just a small margin  -->
            <div class="col-12 col-md-3 bd-sidebar"><form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    
  </div>
</nav>
            </div>
            
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
            
          </div>
          

          
          
            
          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <h1>Source code for sparknlp.base</h1><div class="highlight"><pre>
<span></span><span class="c1">#  Copyright 2017-2021 John Snow Labs</span>
<span class="c1">#</span>
<span class="c1">#  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1">#  you may not use this file except in compliance with the License.</span>
<span class="c1">#  You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1">#  Unless required by applicable law or agreed to in writing, software</span>
<span class="c1">#  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1">#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1">#  See the License for the specific language governing permissions and</span>
<span class="c1">#  limitations under the License.</span>

<span class="sd">&quot;&quot;&quot;Contains all the basic components to create a Spark NLP Pipeline.</span>

<span class="sd">This module contains basic transformers and extensions to the Spark Pipeline</span>
<span class="sd">interface. These are the :class:`LightPipeline` and :class:`RecursivePipeline`</span>
<span class="sd">which offer additional functionality.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABC</span>

<span class="kn">from</span> <span class="nn">pyspark</span> <span class="kn">import</span> <span class="n">keyword_only</span>
<span class="kn">from</span> <span class="nn">pyspark.ml.wrapper</span> <span class="kn">import</span> <span class="n">JavaEstimator</span>
<span class="kn">from</span> <span class="nn">pyspark.ml.param.shared</span> <span class="kn">import</span> <span class="n">Param</span><span class="p">,</span> <span class="n">Params</span><span class="p">,</span> <span class="n">TypeConverters</span>
<span class="kn">from</span> <span class="nn">pyspark.ml.pipeline</span> <span class="kn">import</span> <span class="n">Pipeline</span><span class="p">,</span> <span class="n">PipelineModel</span><span class="p">,</span> <span class="n">Estimator</span><span class="p">,</span> <span class="n">Transformer</span>
<span class="kn">from</span> <span class="nn">sparknlp.common</span> <span class="kn">import</span> <span class="n">AnnotatorProperties</span>
<span class="kn">from</span> <span class="nn">sparknlp.internal</span> <span class="kn">import</span> <span class="n">AnnotatorTransformer</span><span class="p">,</span> <span class="n">RecursiveEstimator</span><span class="p">,</span> <span class="n">RecursiveTransformer</span>

<span class="kn">from</span> <span class="nn">sparknlp.annotation</span> <span class="kn">import</span> <span class="n">Annotation</span>
<span class="kn">import</span> <span class="nn">sparknlp.internal</span> <span class="k">as</span> <span class="nn">_internal</span>


<div class="viewcode-block" id="LightPipeline"><a class="viewcode-back" href="../../reference/autosummary/sparknlp.base.LightPipeline.html#sparknlp.base.LightPipeline">[docs]</a><span class="k">class</span> <span class="nc">LightPipeline</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Creates a LightPipeline from a Spark PipelineModel.</span>

<span class="sd">    LightPipeline is a Spark NLP specific Pipeline class equivalent to Spark</span>
<span class="sd">    ML Pipeline. The difference is that it’s execution does not hold to</span>
<span class="sd">    Spark principles, instead it computes everything locally (but in</span>
<span class="sd">    parallel) in order to achieve fast results when dealing with small</span>
<span class="sd">    amounts of data. This means, we do not input a Spark Dataframe, but a</span>
<span class="sd">    string or an Array of strings instead, to be annotated. To create Light</span>
<span class="sd">    Pipelines, you need to input an already trained (fit) Spark ML Pipeline.</span>

<span class="sd">    It’s :meth:`.transform` has now an alternative :meth:`.annotate`, which</span>
<span class="sd">    directly outputs the results.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pipelineModel : :class:`pyspark.ml.PipelineModel`</span>
<span class="sd">        The PipelineModel containing Spark NLP Annotators</span>
<span class="sd">    parse_embeddings : bool, optional</span>
<span class="sd">        Whether to parse embeddings, by default False</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Use :meth:`.fullAnnotate` to also output the result as</span>
<span class="sd">    :class:`.Annotation`, with metadata.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from sparknlp.base import LightPipeline</span>
<span class="sd">    &gt;&gt;&gt; light = LightPipeline(pipeline.fit(data))</span>
<span class="sd">    &gt;&gt;&gt; light.annotate(&quot;We are very happy about Spark NLP&quot;)</span>
<span class="sd">    {</span>
<span class="sd">        &#39;document&#39;: [&#39;We are very happy about Spark NLP&#39;],</span>
<span class="sd">        &#39;lemmas&#39;: [&#39;We&#39;, &#39;be&#39;, &#39;very&#39;, &#39;happy&#39;, &#39;about&#39;, &#39;Spark&#39;, &#39;NLP&#39;],</span>
<span class="sd">        &#39;pos&#39;: [&#39;PRP&#39;, &#39;VBP&#39;, &#39;RB&#39;, &#39;JJ&#39;, &#39;IN&#39;, &#39;NNP&#39;, &#39;NNP&#39;],</span>
<span class="sd">        &#39;sentence&#39;: [&#39;We are very happy about Spark NLP&#39;],</span>
<span class="sd">        &#39;spell&#39;: [&#39;We&#39;, &#39;are&#39;, &#39;very&#39;, &#39;happy&#39;, &#39;about&#39;, &#39;Spark&#39;, &#39;NLP&#39;],</span>
<span class="sd">        &#39;stems&#39;: [&#39;we&#39;, &#39;ar&#39;, &#39;veri&#39;, &#39;happi&#39;, &#39;about&#39;, &#39;spark&#39;, &#39;nlp&#39;],</span>
<span class="sd">        &#39;token&#39;: [&#39;We&#39;, &#39;are&#39;, &#39;very&#39;, &#39;happy&#39;, &#39;about&#39;, &#39;Spark&#39;, &#39;NLP&#39;]</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pipelineModel</span><span class="p">,</span> <span class="n">parse_embeddings</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pipeline_model</span> <span class="o">=</span> <span class="n">pipelineModel</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lightPipeline</span> <span class="o">=</span> <span class="n">_internal</span><span class="o">.</span><span class="n">_LightPipeline</span><span class="p">(</span><span class="n">pipelineModel</span><span class="p">,</span> <span class="n">parse_embeddings</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">()</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_annotation_from_java</span><span class="p">(</span><span class="n">java_annotations</span><span class="p">):</span>
        <span class="n">annotations</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">annotation</span> <span class="ow">in</span> <span class="n">java_annotations</span><span class="p">:</span>
            <span class="n">annotations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Annotation</span><span class="p">(</span><span class="n">annotation</span><span class="o">.</span><span class="n">annotatorType</span><span class="p">(),</span>
                                          <span class="n">annotation</span><span class="o">.</span><span class="n">begin</span><span class="p">(),</span>
                                          <span class="n">annotation</span><span class="o">.</span><span class="n">end</span><span class="p">(),</span>
                                          <span class="n">annotation</span><span class="o">.</span><span class="n">result</span><span class="p">(),</span>
                                          <span class="n">annotation</span><span class="o">.</span><span class="n">metadata</span><span class="p">(),</span>
                                          <span class="n">annotation</span><span class="o">.</span><span class="n">embeddings</span>
                                          <span class="p">)</span>
                               <span class="p">)</span>
        <span class="k">return</span> <span class="n">annotations</span>

<div class="viewcode-block" id="LightPipeline.fullAnnotate"><a class="viewcode-back" href="../../reference/autosummary/sparknlp.base.LightPipeline.html#sparknlp.base.LightPipeline.fullAnnotate">[docs]</a>    <span class="k">def</span> <span class="nf">fullAnnotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Annotates the data provided into `Annotation` type results.</span>

<span class="sd">        The data should be either a list or a str.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        target : list or str</span>
<span class="sd">            The data to be annotated</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        List[Annotation]</span>
<span class="sd">            The result of the annotation</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from sparknlp.pretrained import PretrainedPipeline</span>
<span class="sd">        &gt;&gt;&gt; explain_document_pipeline = PretrainedPipeline(&quot;explain_document_dl&quot;)</span>
<span class="sd">        &gt;&gt;&gt; result = explain_document_pipeline.fullAnnotate(&#39;U.N. official Ekeus heads for Baghdad.&#39;)</span>
<span class="sd">        &gt;&gt;&gt; result[0].keys()</span>
<span class="sd">        dict_keys([&#39;entities&#39;, &#39;stem&#39;, &#39;checked&#39;, &#39;lemma&#39;, &#39;document&#39;, &#39;pos&#39;, &#39;token&#39;, &#39;ner&#39;, &#39;embeddings&#39;, &#39;sentence&#39;])</span>
<span class="sd">        &gt;&gt;&gt; result[0][&quot;ner&quot;]</span>
<span class="sd">        [Annotation(named_entity, 0, 2, B-ORG, {&#39;word&#39;: &#39;U.N&#39;}),</span>
<span class="sd">        Annotation(named_entity, 3, 3, O, {&#39;word&#39;: &#39;.&#39;}),</span>
<span class="sd">        Annotation(named_entity, 5, 12, O, {&#39;word&#39;: &#39;official&#39;}),</span>
<span class="sd">        Annotation(named_entity, 14, 18, B-PER, {&#39;word&#39;: &#39;Ekeus&#39;}),</span>
<span class="sd">        Annotation(named_entity, 20, 24, O, {&#39;word&#39;: &#39;heads&#39;}),</span>
<span class="sd">        Annotation(named_entity, 26, 28, O, {&#39;word&#39;: &#39;for&#39;}),</span>
<span class="sd">        Annotation(named_entity, 30, 36, B-LOC, {&#39;word&#39;: &#39;Baghdad&#39;}),</span>
<span class="sd">        Annotation(named_entity, 37, 37, O, {&#39;word&#39;: &#39;.&#39;})]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">target</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
            <span class="n">target</span> <span class="o">=</span> <span class="p">[</span><span class="n">target</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lightPipeline</span><span class="o">.</span><span class="n">fullAnnotateJava</span><span class="p">(</span><span class="n">target</span><span class="p">):</span>
            <span class="n">kas</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">atype</span><span class="p">,</span> <span class="n">annotations</span> <span class="ow">in</span> <span class="n">row</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">kas</span><span class="p">[</span><span class="n">atype</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotation_from_java</span><span class="p">(</span><span class="n">annotations</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kas</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="LightPipeline.annotate"><a class="viewcode-back" href="../../reference/autosummary/sparknlp.base.LightPipeline.html#sparknlp.base.LightPipeline.annotate">[docs]</a>    <span class="k">def</span> <span class="nf">annotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Annotates the data provided, extracting the results.</span>

<span class="sd">        The data should be either a list or a str.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        target : list or str</span>
<span class="sd">            The data to be annotated</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        List[dict] or dict</span>
<span class="sd">            The result of the annotation</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from sparknlp.pretrained import PretrainedPipeline</span>
<span class="sd">        &gt;&gt;&gt; explain_document_pipeline = PretrainedPipeline(&quot;explain_document_dl&quot;)</span>
<span class="sd">        &gt;&gt;&gt; result = explain_document_pipeline.annotate(&#39;U.N. official Ekeus heads for Baghdad.&#39;)</span>
<span class="sd">        &gt;&gt;&gt; result.keys()</span>
<span class="sd">        dict_keys([&#39;entities&#39;, &#39;stem&#39;, &#39;checked&#39;, &#39;lemma&#39;, &#39;document&#39;, &#39;pos&#39;, &#39;token&#39;, &#39;ner&#39;, &#39;embeddings&#39;, &#39;sentence&#39;])</span>
<span class="sd">        &gt;&gt;&gt; result[&quot;ner&quot;]</span>
<span class="sd">        [&#39;B-ORG&#39;, &#39;O&#39;, &#39;O&#39;, &#39;B-PER&#39;, &#39;O&#39;, &#39;O&#39;, &#39;B-LOC&#39;, &#39;O&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">reformat</span><span class="p">(</span><span class="n">annotations</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">annotations</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

        <span class="n">annotations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lightPipeline</span><span class="o">.</span><span class="n">annotateJava</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">target</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">reformat</span><span class="p">(</span><span class="n">annotations</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">target</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">reformat</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nb">list</span><span class="p">(</span><span class="n">annotations</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;target for annotation may be &#39;str&#39; or &#39;list&#39;&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="LightPipeline.transform"><a class="viewcode-back" href="../../reference/autosummary/sparknlp.base.LightPipeline.html#sparknlp.base.LightPipeline.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataframe</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Transforms a dataframe provided with the stages of the LightPipeline.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dataframe : :class:`pyspark.sql.DataFrame`</span>
<span class="sd">            The Dataframe to be transformed</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`pyspark.sql.DataFrame`</span>
<span class="sd">            The transformed DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pipeline_model</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">dataframe</span><span class="p">)</span></div>

<div class="viewcode-block" id="LightPipeline.setIgnoreUnsupported"><a class="viewcode-back" href="../../reference/autosummary/sparknlp.base.LightPipeline.html#sparknlp.base.LightPipeline.setIgnoreUnsupported">[docs]</a>    <span class="k">def</span> <span class="nf">setIgnoreUnsupported</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets whether to ignore unsupported AnnotatorModels.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : bool</span>
<span class="sd">            Whether to ignore unsupported AnnotatorModels.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        LightPipeline</span>
<span class="sd">            The current LightPipeline</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lightPipeline</span><span class="o">.</span><span class="n">setIgnoreUnsupported</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="LightPipeline.getIgnoreUnsupported"><a class="viewcode-back" href="../../reference/autosummary/sparknlp.base.LightPipeline.html#sparknlp.base.LightPipeline.getIgnoreUnsupported">[docs]</a>    <span class="k">def</span> <span class="nf">getIgnoreUnsupported</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gets whether to ignore unsupported AnnotatorModels.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            Whether to ignore unsupported AnnotatorModels.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lightPipeline</span><span class="o">.</span><span class="n">getIgnoreUnsupported</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="RecursivePipeline"><a class="viewcode-back" href="../../reference/autosummary/sparknlp.base.RecursivePipeline.html#sparknlp.base.RecursivePipeline">[docs]</a><span class="k">class</span> <span class="nc">RecursivePipeline</span><span class="p">(</span><span class="n">Pipeline</span><span class="p">,</span> <span class="n">JavaEstimator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Recursive pipelines are Spark NLP specific pipelines that allow a Spark</span>
<span class="sd">    ML Pipeline to know about itself on every Pipeline Stage task.</span>

<span class="sd">    This allows annotators to utilize this same pipeline against external</span>
<span class="sd">    resources to process them in the same way the user decides.</span>

<span class="sd">    Only some of the annotators take advantage of this. RecursivePipeline</span>
<span class="sd">    behaves exactly the same as normal Spark ML pipelines, so they can be used</span>
<span class="sd">    with the same intention.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from sparknlp.annotator import *</span>
<span class="sd">    &gt;&gt;&gt; from sparknlp.base import *</span>
<span class="sd">    &gt;&gt;&gt; recursivePipeline = RecursivePipeline(stages=[</span>
<span class="sd">    ...     documentAssembler,</span>
<span class="sd">    ...     sentenceDetector,</span>
<span class="sd">    ...     tokenizer,</span>
<span class="sd">    ...     lemmatizer,</span>
<span class="sd">    ...     finisher</span>
<span class="sd">    ... ])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@keyword_only</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">RecursivePipeline</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_java_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_java_obj</span><span class="p">(</span><span class="s2">&quot;com.johnsnowlabs.nlp.RecursivePipeline&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">uid</span><span class="p">)</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_kwargs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setParams</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">):</span>
        <span class="n">stages</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getStages</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">stage</span> <span class="ow">in</span> <span class="n">stages</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">stage</span><span class="p">,</span> <span class="n">Estimator</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stage</span><span class="p">,</span> <span class="n">Transformer</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot recognize a pipeline stage of type </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">stage</span><span class="p">))</span>
        <span class="n">indexOfLastEstimator</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">stage</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">stages</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stage</span><span class="p">,</span> <span class="n">Estimator</span><span class="p">):</span>
                <span class="n">indexOfLastEstimator</span> <span class="o">=</span> <span class="n">i</span>
        <span class="n">transformers</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">stage</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">stages</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">indexOfLastEstimator</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stage</span><span class="p">,</span> <span class="n">Transformer</span><span class="p">):</span>
                    <span class="n">transformers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stage</span><span class="p">)</span>
                    <span class="n">dataset</span> <span class="o">=</span> <span class="n">stage</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stage</span><span class="p">,</span> <span class="n">RecursiveEstimator</span><span class="p">):</span>
                    <span class="n">model</span> <span class="o">=</span> <span class="n">stage</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">pipeline</span><span class="o">=</span><span class="n">PipelineModel</span><span class="p">(</span><span class="n">transformers</span><span class="p">))</span>
                    <span class="n">transformers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">indexOfLastEstimator</span><span class="p">:</span>
                        <span class="n">dataset</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">model</span> <span class="o">=</span> <span class="n">stage</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
                    <span class="n">transformers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">indexOfLastEstimator</span><span class="p">:</span>
                        <span class="n">dataset</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">transformers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stage</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">PipelineModel</span><span class="p">(</span><span class="n">transformers</span><span class="p">)</span></div>


<div class="viewcode-block" id="RecursivePipelineModel"><a class="viewcode-back" href="../../reference/autosummary/sparknlp.base.RecursivePipelineModel.html#sparknlp.base.RecursivePipelineModel">[docs]</a><span class="k">class</span> <span class="nc">RecursivePipelineModel</span><span class="p">(</span><span class="n">PipelineModel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Fitted RecursivePipeline.</span>

<span class="sd">    Behaves the same as a Spark PipelineModel does. Not intended to be</span>
<span class="sd">    initialized by itself. To create a RecursivePipelineModel please fit data to</span>
<span class="sd">    a :class:`.RecursivePipeline`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pipeline_model</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">PipelineModel</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stages</span> <span class="o">=</span> <span class="n">pipeline_model</span><span class="o">.</span><span class="n">stages</span>

    <span class="k">def</span> <span class="nf">_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stages</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">HasRecursiveTransform</span><span class="p">):</span>
                <span class="c1"># drops current stage from the recursive pipeline within</span>
                <span class="n">dataset</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">transform_recursive</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">PipelineModel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stages</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">AnnotatorProperties</span><span class="p">)</span> <span class="ow">and</span> <span class="n">t</span><span class="o">.</span><span class="n">getLazyAnnotator</span><span class="p">():</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dataset</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dataset</span></div>


<div class="viewcode-block" id="HasRecursiveFit"><a class="viewcode-back" href="../../reference/autosummary/sparknlp.base.HasRecursiveFit.html#sparknlp.base.HasRecursiveFit">[docs]</a><span class="k">class</span> <span class="nc">HasRecursiveFit</span><span class="p">(</span><span class="n">RecursiveEstimator</span><span class="p">,</span> <span class="n">ABC</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Properties for the implementation of the RecursivePipeline.&quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="HasRecursiveTransform"><a class="viewcode-back" href="../../reference/autosummary/sparknlp.base.HasRecursiveTransform.html#sparknlp.base.HasRecursiveTransform">[docs]</a><span class="k">class</span> <span class="nc">HasRecursiveTransform</span><span class="p">(</span><span class="n">RecursiveTransformer</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Properties for the implementation of the RecursivePipeline.&quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="DocumentAssembler"><a class="viewcode-back" href="../../reference/autosummary/sparknlp.base.DocumentAssembler.html#sparknlp.base.DocumentAssembler">[docs]</a><span class="k">class</span> <span class="nc">DocumentAssembler</span><span class="p">(</span><span class="n">AnnotatorTransformer</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Prepares data into a format that is processable by Spark NLP.</span>

<span class="sd">    This is the entry point for every Spark NLP pipeline. The</span>
<span class="sd">    `DocumentAssembler` can read either a ``String`` column or an</span>
<span class="sd">    ``Array[String]``. Additionally, :meth:`.setCleanupMode` can be used to</span>
<span class="sd">    pre-process the text (Default: ``disabled``). For possible options please</span>
<span class="sd">    refer the parameters section.</span>

<span class="sd">    For more extended examples on document pre-processing see the</span>
<span class="sd">    `Spark NLP Workshop &lt;https://github.com/JohnSnowLabs/spark-nlp-workshop/blob/master/tutorials/Certification_Trainings/Public/2.Text_Preprocessing_with_SparkNLP_Annotators_Transformers.ipynb&gt;`__.</span>

<span class="sd">    ====================== ======================</span>
<span class="sd">    Input Annotation types Output Annotation type</span>
<span class="sd">    ====================== ======================</span>
<span class="sd">    ``NONE``               ``DOCUMENT``</span>
<span class="sd">    ====================== ======================</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    inputCol</span>
<span class="sd">        Input column name</span>
<span class="sd">    outputCol</span>
<span class="sd">        Output column name</span>
<span class="sd">    idCol</span>
<span class="sd">        Name of String type column for row id.</span>
<span class="sd">    metadataCol</span>
<span class="sd">        Name of Map type column with metadata information</span>
<span class="sd">    calculationsCol</span>
<span class="sd">        Name of float vector map column to use for embeddings and other</span>
<span class="sd">        representations.</span>
<span class="sd">    cleanupMode</span>
<span class="sd">        How to cleanup the document , by default disabled.</span>
<span class="sd">        Possible values: ``disabled, inplace, inplace_full, shrink, shrink_full,</span>
<span class="sd">        each, each_full, delete_full``</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import sparknlp</span>
<span class="sd">    &gt;&gt;&gt; from sparknlp.base import *</span>
<span class="sd">    &gt;&gt;&gt; from pyspark.ml import Pipeline</span>
<span class="sd">    &gt;&gt;&gt; data = spark.createDataFrame([[&quot;Spark NLP is an open-source text processing library.&quot;]]).toDF(&quot;text&quot;)</span>
<span class="sd">    &gt;&gt;&gt; documentAssembler = DocumentAssembler().setInputCol(&quot;text&quot;).setOutputCol(&quot;document&quot;)</span>
<span class="sd">    &gt;&gt;&gt; result = documentAssembler.transform(data)</span>
<span class="sd">    &gt;&gt;&gt; result.select(&quot;document&quot;).show(truncate=False)</span>
<span class="sd">    +----------------------------------------------------------------------------------------------+</span>
<span class="sd">    |document                                                                                      |</span>
<span class="sd">    +----------------------------------------------------------------------------------------------+</span>
<span class="sd">    |[[document, 0, 51, Spark NLP is an open-source text processing library., [sentence -&gt; 0], []]]|</span>
<span class="sd">    +----------------------------------------------------------------------------------------------+</span>
<span class="sd">    &gt;&gt;&gt; result.select(&quot;document&quot;).printSchema()</span>
<span class="sd">    root</span>
<span class="sd">    |-- document: array (nullable = True)</span>
<span class="sd">    |    |-- element: struct (containsNull = True)</span>
<span class="sd">    |    |    |-- annotatorType: string (nullable = True)</span>
<span class="sd">    |    |    |-- begin: integer (nullable = False)</span>
<span class="sd">    |    |    |-- end: integer (nullable = False)</span>
<span class="sd">    |    |    |-- result: string (nullable = True)</span>
<span class="sd">    |    |    |-- metadata: map (nullable = True)</span>
<span class="sd">    |    |    |    |-- key: string</span>
<span class="sd">    |    |    |    |-- value: string (valueContainsNull = True)</span>
<span class="sd">    |    |    |-- embeddings: array (nullable = True)</span>
<span class="sd">    |    |    |    |-- element: float (containsNull = False)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">inputCol</span> <span class="o">=</span> <span class="n">Param</span><span class="p">(</span><span class="n">Params</span><span class="o">.</span><span class="n">_dummy</span><span class="p">(),</span> <span class="s2">&quot;inputCol&quot;</span><span class="p">,</span> <span class="s2">&quot;input column name&quot;</span><span class="p">,</span> <span class="n">typeConverter</span><span class="o">=</span><span class="n">TypeConverters</span><span class="o">.</span><span class="n">toString</span><span class="p">)</span>
    <span class="n">outputCol</span> <span class="o">=</span> <span class="n">Param</span><span class="p">(</span><span class="n">Params</span><span class="o">.</span><span class="n">_dummy</span><span class="p">(),</span> <span class="s2">&quot;outputCol&quot;</span><span class="p">,</span> <span class="s2">&quot;output column name&quot;</span><span class="p">,</span> <span class="n">typeConverter</span><span class="o">=</span><span class="n">TypeConverters</span><span class="o">.</span><span class="n">toString</span><span class="p">)</span>
    <span class="n">idCol</span> <span class="o">=</span> <span class="n">Param</span><span class="p">(</span><span class="n">Params</span><span class="o">.</span><span class="n">_dummy</span><span class="p">(),</span> <span class="s2">&quot;idCol&quot;</span><span class="p">,</span> <span class="s2">&quot;column for setting an id to such string in row&quot;</span><span class="p">,</span> <span class="n">typeConverter</span><span class="o">=</span><span class="n">TypeConverters</span><span class="o">.</span><span class="n">toString</span><span class="p">)</span>
    <span class="n">metadataCol</span> <span class="o">=</span> <span class="n">Param</span><span class="p">(</span><span class="n">Params</span><span class="o">.</span><span class="n">_dummy</span><span class="p">(),</span> <span class="s2">&quot;metadataCol&quot;</span><span class="p">,</span> <span class="s2">&quot;String to String map column to use as metadata&quot;</span><span class="p">,</span> <span class="n">typeConverter</span><span class="o">=</span><span class="n">TypeConverters</span><span class="o">.</span><span class="n">toString</span><span class="p">)</span>
    <span class="n">calculationsCol</span> <span class="o">=</span> <span class="n">Param</span><span class="p">(</span><span class="n">Params</span><span class="o">.</span><span class="n">_dummy</span><span class="p">(),</span> <span class="s2">&quot;calculationsCol&quot;</span><span class="p">,</span> <span class="s2">&quot;String to Float vector map column to use as embeddigns and other representations&quot;</span><span class="p">,</span> <span class="n">typeConverter</span><span class="o">=</span><span class="n">TypeConverters</span><span class="o">.</span><span class="n">toString</span><span class="p">)</span>
    <span class="n">cleanupMode</span> <span class="o">=</span> <span class="n">Param</span><span class="p">(</span><span class="n">Params</span><span class="o">.</span><span class="n">_dummy</span><span class="p">(),</span> <span class="s2">&quot;cleanupMode&quot;</span><span class="p">,</span> <span class="s2">&quot;possible values: disabled, inplace, inplace_full, shrink, shrink_full, each, each_full, delete_full&quot;</span><span class="p">,</span> <span class="n">typeConverter</span><span class="o">=</span><span class="n">TypeConverters</span><span class="o">.</span><span class="n">toString</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;DocumentAssembler&#39;</span>

    <span class="nd">@keyword_only</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">DocumentAssembler</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">classname</span><span class="o">=</span><span class="s2">&quot;com.johnsnowlabs.nlp.DocumentAssembler&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setDefault</span><span class="p">(</span><span class="n">outputCol</span><span class="o">=</span><span class="s2">&quot;document&quot;</span><span class="p">,</span> <span class="n">cleanupMode</span><span class="o">=</span><span class="s1">&#39;disabled&#39;</span><span class="p">)</span>

    <span class="nd">@keyword_only</span>
    <span class="k">def</span> <span class="nf">setParams</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_kwargs</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="DocumentAssembler.setInputCol"><a class="viewcode-back" href="../../reference/autosummary/sparknlp.base.DocumentAssembler.html#sparknlp.base.DocumentAssembler.setInputCol">[docs]</a>    <span class="k">def</span> <span class="nf">setInputCol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets input column name.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : str</span>
<span class="sd">            Name of the input column</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set</span><span class="p">(</span><span class="n">inputCol</span><span class="o">=</span><span class="n">value</span><span class="p">)</span></div>

<div class="viewcode-block" id="DocumentAssembler.setOutputCol"><a class="viewcode-back" href="../../reference/autosummary/sparknlp.base.DocumentAssembler.html#sparknlp.base.DocumentAssembler.setOutputCol">[docs]</a>    <span class="k">def</span> <span class="nf">setOutputCol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets output column name.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : str</span>
<span class="sd">            Name of the Output Column</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set</span><span class="p">(</span><span class="n">outputCol</span><span class="o">=</span><span class="n">value</span><span class="p">)</span></div>

<div class="viewcode-block" id="DocumentAssembler.setIdCol"><a class="viewcode-back" href="../../reference/autosummary/sparknlp.base.DocumentAssembler.html#sparknlp.base.DocumentAssembler.setIdCol">[docs]</a>    <span class="k">def</span> <span class="nf">setIdCol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets name of string type column for row id.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : str</span>
<span class="sd">            Name of the Id Column</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set</span><span class="p">(</span><span class="n">idCol</span><span class="o">=</span><span class="n">value</span><span class="p">)</span></div>

<div class="viewcode-block" id="DocumentAssembler.setMetadataCol"><a class="viewcode-back" href="../../reference/autosummary/sparknlp.base.DocumentAssembler.html#sparknlp.base.DocumentAssembler.setMetadataCol">[docs]</a>    <span class="k">def</span> <span class="nf">setMetadataCol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets name for Map type column with metadata information.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : str</span>
<span class="sd">            Name of the metadata column</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set</span><span class="p">(</span><span class="n">metadataCol</span><span class="o">=</span><span class="n">value</span><span class="p">)</span></div>

<div class="viewcode-block" id="DocumentAssembler.setCalculationsCol"><a class="viewcode-back" href="../../reference/autosummary/sparknlp.base.DocumentAssembler.html#sparknlp.base.DocumentAssembler.setCalculationsCol">[docs]</a>    <span class="k">def</span> <span class="nf">setCalculationsCol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets name of float vector map column to use for embeddings and other</span>
<span class="sd">        representations.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : str</span>
<span class="sd">            Name of the calculations column</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set</span><span class="p">(</span><span class="n">metadataCol</span><span class="o">=</span><span class="n">value</span><span class="p">)</span></div>

<div class="viewcode-block" id="DocumentAssembler.setCleanupMode"><a class="viewcode-back" href="../../reference/autosummary/sparknlp.base.DocumentAssembler.html#sparknlp.base.DocumentAssembler.setCleanupMode">[docs]</a>    <span class="k">def</span> <span class="nf">setCleanupMode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets how to cleanup the document, by default disabled.</span>
<span class="sd">        Possible values: ``disabled, inplace, inplace_full, shrink, shrink_full,</span>
<span class="sd">        each, each_full, delete_full``</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : str</span>
<span class="sd">            Cleanup mode</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;disabled&#39;</span><span class="p">,</span> <span class="s1">&#39;inplace&#39;</span><span class="p">,</span> <span class="s1">&#39;inplace_full&#39;</span><span class="p">,</span> <span class="s1">&#39;shrink&#39;</span><span class="p">,</span> <span class="s1">&#39;shrink_full&#39;</span><span class="p">,</span> <span class="s1">&#39;each&#39;</span><span class="p">,</span> <span class="s1">&#39;each_full&#39;</span><span class="p">,</span> <span class="s1">&#39;delete_full&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Cleanup mode possible values: disabled, inplace, inplace_full, shrink, shrink_full, each, each_full, delete_full&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set</span><span class="p">(</span><span class="n">cleanupMode</span><span class="o">=</span><span class="n">value</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="TokenAssembler"><a class="viewcode-back" href="../../reference/autosummary/sparknlp.base.TokenAssembler.html#sparknlp.base.TokenAssembler">[docs]</a><span class="k">class</span> <span class="nc">TokenAssembler</span><span class="p">(</span><span class="n">AnnotatorTransformer</span><span class="p">,</span> <span class="n">AnnotatorProperties</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This transformer reconstructs a ``DOCUMENT`` type annotation from tokens,</span>
<span class="sd">    usually after these have been normalized, lemmatized, normalized, spell</span>
<span class="sd">    checked, etc, in order to use this document annotation in further</span>
<span class="sd">    annotators. Requires ``DOCUMENT`` and ``TOKEN`` type annotations as input.</span>

<span class="sd">    For more extended examples on document pre-processing see the</span>
<span class="sd">    `Spark NLP Workshop &lt;https://github.com/JohnSnowLabs/spark-nlp-workshop/blob/master/tutorials/Certification_Trainings/Public/2.Text_Preprocessing_with_SparkNLP_Annotators_Transformers.ipynb&gt;`__.</span>

<span class="sd">    ====================== ======================</span>
<span class="sd">    Input Annotation types Output Annotation type</span>
<span class="sd">    ====================== ======================</span>
<span class="sd">    ``DOCUMENT, TOKEN``    ``DOCUMENT``</span>
<span class="sd">    ====================== ======================</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    preservePosition</span>
<span class="sd">        Whether to preserve the actual position of the tokens or reduce them to</span>
<span class="sd">        one space</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import sparknlp</span>
<span class="sd">    &gt;&gt;&gt; from sparknlp.base import *</span>
<span class="sd">    &gt;&gt;&gt; from sparknlp.annotator import *</span>
<span class="sd">    &gt;&gt;&gt; from pyspark.ml import Pipeline</span>

<span class="sd">    First, the text is tokenized and cleaned</span>

<span class="sd">    &gt;&gt;&gt; documentAssembler = DocumentAssembler() \\</span>
<span class="sd">    ...    .setInputCol(&quot;text&quot;) \\</span>
<span class="sd">    ...    .setOutputCol(&quot;document&quot;)</span>
<span class="sd">    &gt;&gt;&gt; sentenceDetector = SentenceDetector() \\</span>
<span class="sd">    ...    .setInputCols([&quot;document&quot;]) \\</span>
<span class="sd">    ...    .setOutputCol(&quot;sentences&quot;)</span>
<span class="sd">    &gt;&gt;&gt; tokenizer = Tokenizer() \\</span>
<span class="sd">    ...    .setInputCols([&quot;sentences&quot;]) \\</span>
<span class="sd">    ...    .setOutputCol(&quot;token&quot;)</span>
<span class="sd">    &gt;&gt;&gt; normalizer = Normalizer() \\</span>
<span class="sd">    ...    .setInputCols([&quot;token&quot;]) \\</span>
<span class="sd">    ...    .setOutputCol(&quot;normalized&quot;) \\</span>
<span class="sd">    ...    .setLowercase(False)</span>
<span class="sd">    &gt;&gt;&gt; stopwordsCleaner = StopWordsCleaner() \\</span>
<span class="sd">    ...    .setInputCols([&quot;normalized&quot;]) \\</span>
<span class="sd">    ...    .setOutputCol(&quot;cleanTokens&quot;) \\</span>
<span class="sd">    ...    .setCaseSensitive(False)</span>

<span class="sd">    Then the TokenAssembler turns the cleaned tokens into a ``DOCUMENT`` type</span>
<span class="sd">    structure.</span>

<span class="sd">    &gt;&gt;&gt; tokenAssembler = TokenAssembler() \\</span>
<span class="sd">    ...    .setInputCols([&quot;sentences&quot;, &quot;cleanTokens&quot;]) \\</span>
<span class="sd">    ...    .setOutputCol(&quot;cleanText&quot;)</span>
<span class="sd">    &gt;&gt;&gt; data = spark.createDataFrame([[&quot;Spark NLP is an open-source text processing library for advanced natural language processing.&quot;]]) \\</span>
<span class="sd">    ...    .toDF(&quot;text&quot;)</span>
<span class="sd">    &gt;&gt;&gt; pipeline = Pipeline().setStages([</span>
<span class="sd">    ...     documentAssembler,</span>
<span class="sd">    ...     sentenceDetector,</span>
<span class="sd">    ...     tokenizer,</span>
<span class="sd">    ...     normalizer,</span>
<span class="sd">    ...     stopwordsCleaner,</span>
<span class="sd">    ...     tokenAssembler</span>
<span class="sd">    ... ]).fit(data)</span>
<span class="sd">    &gt;&gt;&gt; result = pipeline.transform(data)</span>
<span class="sd">    &gt;&gt;&gt; result.select(&quot;cleanText&quot;).show(truncate=False)</span>
<span class="sd">    +---------------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">    |cleanText                                                                                                                  |</span>
<span class="sd">    +---------------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">    |[[document, 0, 80, Spark NLP opensource text processing library advanced natural language processing, [sentence -&gt; 0], []]]|</span>
<span class="sd">    +---------------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;TokenAssembler&quot;</span>
    <span class="n">preservePosition</span> <span class="o">=</span> <span class="n">Param</span><span class="p">(</span><span class="n">Params</span><span class="o">.</span><span class="n">_dummy</span><span class="p">(),</span> <span class="s2">&quot;preservePosition&quot;</span><span class="p">,</span> <span class="s2">&quot;whether to preserve the actual position of the tokens or reduce them to one space&quot;</span><span class="p">,</span> <span class="n">typeConverter</span><span class="o">=</span><span class="n">TypeConverters</span><span class="o">.</span><span class="n">toBoolean</span><span class="p">)</span>

    <span class="nd">@keyword_only</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">TokenAssembler</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">classname</span><span class="o">=</span><span class="s2">&quot;com.johnsnowlabs.nlp.TokenAssembler&quot;</span><span class="p">)</span>

    <span class="nd">@keyword_only</span>
    <span class="k">def</span> <span class="nf">setParams</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_kwargs</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="TokenAssembler.setPreservePosition"><a class="viewcode-back" href="../../reference/autosummary/sparknlp.base.TokenAssembler.html#sparknlp.base.TokenAssembler.setPreservePosition">[docs]</a>    <span class="k">def</span> <span class="nf">setPreservePosition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets whether to preserve the actual position of the tokens or reduce</span>
<span class="sd">        them to one space.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : str</span>
<span class="sd">            Name of the Id Column</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set</span><span class="p">(</span><span class="n">preservePosition</span><span class="o">=</span><span class="n">value</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Doc2Chunk"><a class="viewcode-back" href="../../reference/autosummary/sparknlp.base.Doc2Chunk.html#sparknlp.base.Doc2Chunk">[docs]</a><span class="k">class</span> <span class="nc">Doc2Chunk</span><span class="p">(</span><span class="n">AnnotatorTransformer</span><span class="p">,</span> <span class="n">AnnotatorProperties</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Converts ``DOCUMENT`` type annotations into ``CHUNK`` type with the</span>
<span class="sd">    contents of a ``chunkCol``.</span>

<span class="sd">    Chunk text must be contained within input ``DOCUMENT``. May be either</span>
<span class="sd">    ``StringType`` or ``ArrayType[StringType]`` (using setIsArray). Useful for</span>
<span class="sd">    annotators that require a CHUNK type input.</span>

<span class="sd">    For more extended examples on document pre-processing see the</span>
<span class="sd">    `Spark NLP Workshop &lt;https://github.com/JohnSnowLabs/spark-nlp-workshop/blob/master/tutorials/Certification_Trainings/Public/2.Text_Preprocessing_with_SparkNLP_Annotators_Transformers.ipynb&gt;`__.</span>

<span class="sd">    ====================== ======================</span>
<span class="sd">    Input Annotation types Output Annotation type</span>
<span class="sd">    ====================== ======================</span>
<span class="sd">    ``DOCUMENT``           ``CHUNK``</span>
<span class="sd">    ====================== ======================</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    chunkCol</span>
<span class="sd">        Column that contains the string. Must be part of DOCUMENT</span>
<span class="sd">    startCol</span>
<span class="sd">        Column that has a reference of where the chunk begins</span>
<span class="sd">    startColByTokenIndex</span>
<span class="sd">        Whether start column is prepended by whitespace tokens</span>
<span class="sd">    isArray</span>
<span class="sd">        Whether the chunkCol is an array of strings, by default False</span>
<span class="sd">    failOnMissing</span>
<span class="sd">        Whether to fail the job if a chunk is not found within document.</span>
<span class="sd">        Return empty otherwise</span>
<span class="sd">    lowerCase</span>
<span class="sd">        Whether to lower case for matching case</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import sparknlp</span>
<span class="sd">    &gt;&gt;&gt; from sparknlp.base import *</span>
<span class="sd">    &gt;&gt;&gt; from sparknlp.common import *</span>
<span class="sd">    &gt;&gt;&gt; from sparknlp.annotator import *</span>
<span class="sd">    &gt;&gt;&gt; from sparknlp.training import *</span>
<span class="sd">    &gt;&gt;&gt; from pyspark.ml import Pipeline</span>
<span class="sd">    &gt;&gt;&gt; documentAssembler = DocumentAssembler().setInputCol(&quot;text&quot;).setOutputCol(&quot;document&quot;)</span>
<span class="sd">    &gt;&gt;&gt; chunkAssembler = Doc2Chunk() \\</span>
<span class="sd">    ...     .setInputCols(&quot;document&quot;) \\</span>
<span class="sd">    ...     .setChunkCol(&quot;target&quot;) \\</span>
<span class="sd">    ...     .setOutputCol(&quot;chunk&quot;) \\</span>
<span class="sd">    ...     .setIsArray(True)</span>
<span class="sd">    &gt;&gt;&gt; data = spark.createDataFrame([[</span>
<span class="sd">    ...     &quot;Spark NLP is an open-source text processing library for advanced natural language processing.&quot;,</span>
<span class="sd">    ...     [&quot;Spark NLP&quot;, &quot;text processing library&quot;, &quot;natural language processing&quot;]</span>
<span class="sd">    ... ]]).toDF(&quot;text&quot;, &quot;target&quot;)</span>
<span class="sd">    &gt;&gt;&gt; pipeline = Pipeline().setStages([documentAssembler, chunkAssembler]).fit(data)</span>
<span class="sd">    &gt;&gt;&gt; result = pipeline.transform(data)</span>
<span class="sd">    &gt;&gt;&gt; result.selectExpr(&quot;chunk.result&quot;, &quot;chunk.annotatorType&quot;).show(truncate=False)</span>
<span class="sd">    +-----------------------------------------------------------------+---------------------+</span>
<span class="sd">    |result                                                           |annotatorType        |</span>
<span class="sd">    +-----------------------------------------------------------------+---------------------+</span>
<span class="sd">    |[Spark NLP, text processing library, natural language processing]|[chunk, chunk, chunk]|</span>
<span class="sd">    +-----------------------------------------------------------------+---------------------+</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    Chunk2Doc : for converting `CHUNK` annotations to `DOCUMENT`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">chunkCol</span> <span class="o">=</span> <span class="n">Param</span><span class="p">(</span><span class="n">Params</span><span class="o">.</span><span class="n">_dummy</span><span class="p">(),</span> <span class="s2">&quot;chunkCol&quot;</span><span class="p">,</span> <span class="s2">&quot;column that contains string. Must be part of DOCUMENT&quot;</span><span class="p">,</span> <span class="n">typeConverter</span><span class="o">=</span><span class="n">TypeConverters</span><span class="o">.</span><span class="n">toString</span><span class="p">)</span>
    <span class="n">startCol</span> <span class="o">=</span> <span class="n">Param</span><span class="p">(</span><span class="n">Params</span><span class="o">.</span><span class="n">_dummy</span><span class="p">(),</span> <span class="s2">&quot;startCol&quot;</span><span class="p">,</span> <span class="s2">&quot;column that has a reference of where chunk begins&quot;</span><span class="p">,</span> <span class="n">typeConverter</span><span class="o">=</span><span class="n">TypeConverters</span><span class="o">.</span><span class="n">toString</span><span class="p">)</span>
    <span class="n">startColByTokenIndex</span> <span class="o">=</span> <span class="n">Param</span><span class="p">(</span><span class="n">Params</span><span class="o">.</span><span class="n">_dummy</span><span class="p">(),</span> <span class="s2">&quot;startColByTokenIndex&quot;</span><span class="p">,</span> <span class="s2">&quot;whether start col is by whitespace tokens&quot;</span><span class="p">,</span> <span class="n">typeConverter</span><span class="o">=</span><span class="n">TypeConverters</span><span class="o">.</span><span class="n">toBoolean</span><span class="p">)</span>
    <span class="n">isArray</span> <span class="o">=</span> <span class="n">Param</span><span class="p">(</span><span class="n">Params</span><span class="o">.</span><span class="n">_dummy</span><span class="p">(),</span> <span class="s2">&quot;isArray&quot;</span><span class="p">,</span> <span class="s2">&quot;whether the chunkCol is an array of strings&quot;</span><span class="p">,</span> <span class="n">typeConverter</span><span class="o">=</span><span class="n">TypeConverters</span><span class="o">.</span><span class="n">toBoolean</span><span class="p">)</span>
    <span class="n">failOnMissing</span> <span class="o">=</span> <span class="n">Param</span><span class="p">(</span><span class="n">Params</span><span class="o">.</span><span class="n">_dummy</span><span class="p">(),</span> <span class="s2">&quot;failOnMissing&quot;</span><span class="p">,</span> <span class="s2">&quot;whether to fail the job if a chunk is not found within document. return empty otherwise&quot;</span><span class="p">,</span> <span class="n">typeConverter</span><span class="o">=</span><span class="n">TypeConverters</span><span class="o">.</span><span class="n">toBoolean</span><span class="p">)</span>
    <span class="n">lowerCase</span> <span class="o">=</span> <span class="n">Param</span><span class="p">(</span><span class="n">Params</span><span class="o">.</span><span class="n">_dummy</span><span class="p">(),</span> <span class="s2">&quot;lowerCase&quot;</span><span class="p">,</span> <span class="s2">&quot;whether to lower case for matching case&quot;</span><span class="p">,</span> <span class="n">typeConverter</span><span class="o">=</span><span class="n">TypeConverters</span><span class="o">.</span><span class="n">toBoolean</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Doc2Chunk&quot;</span>

    <span class="nd">@keyword_only</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Doc2Chunk</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">classname</span><span class="o">=</span><span class="s2">&quot;com.johnsnowlabs.nlp.Doc2Chunk&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setDefault</span><span class="p">(</span>
            <span class="n">isArray</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>

    <span class="nd">@keyword_only</span>
    <span class="k">def</span> <span class="nf">setParams</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_kwargs</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="Doc2Chunk.setChunkCol"><a class="viewcode-back" href="../../reference/autosummary/sparknlp.base.Doc2Chunk.html#sparknlp.base.Doc2Chunk.setChunkCol">[docs]</a>    <span class="k">def</span> <span class="nf">setChunkCol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets column that contains the string. Must be part of DOCUMENT.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : str</span>
<span class="sd">            Name of the Chunk Column</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set</span><span class="p">(</span><span class="n">chunkCol</span><span class="o">=</span><span class="n">value</span><span class="p">)</span></div>

<div class="viewcode-block" id="Doc2Chunk.setIsArray"><a class="viewcode-back" href="../../reference/autosummary/sparknlp.base.Doc2Chunk.html#sparknlp.base.Doc2Chunk.setIsArray">[docs]</a>    <span class="k">def</span> <span class="nf">setIsArray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets whether the chunkCol is an array of strings.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : bool</span>
<span class="sd">            Whether the chunkCol is an array of strings</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set</span><span class="p">(</span><span class="n">isArray</span><span class="o">=</span><span class="n">value</span><span class="p">)</span></div>

<div class="viewcode-block" id="Doc2Chunk.setStartCol"><a class="viewcode-back" href="../../reference/autosummary/sparknlp.base.Doc2Chunk.html#sparknlp.base.Doc2Chunk.setStartCol">[docs]</a>    <span class="k">def</span> <span class="nf">setStartCol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets column that has a reference of where chunk begins.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : str</span>
<span class="sd">            Name of the reference column</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set</span><span class="p">(</span><span class="n">startCol</span><span class="o">=</span><span class="n">value</span><span class="p">)</span></div>

<div class="viewcode-block" id="Doc2Chunk.setStartColByTokenIndex"><a class="viewcode-back" href="../../reference/autosummary/sparknlp.base.Doc2Chunk.html#sparknlp.base.Doc2Chunk.setStartColByTokenIndex">[docs]</a>    <span class="k">def</span> <span class="nf">setStartColByTokenIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets whether start column is prepended by whitespace tokens.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : bool</span>
<span class="sd">            whether start column is prepended by whitespace tokens</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set</span><span class="p">(</span><span class="n">startColByTokenIndex</span><span class="o">=</span><span class="n">value</span><span class="p">)</span></div>

<div class="viewcode-block" id="Doc2Chunk.setFailOnMissing"><a class="viewcode-back" href="../../reference/autosummary/sparknlp.base.Doc2Chunk.html#sparknlp.base.Doc2Chunk.setFailOnMissing">[docs]</a>    <span class="k">def</span> <span class="nf">setFailOnMissing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets whether to fail the job if a chunk is not found within document.</span>
<span class="sd">        Return empty otherwise.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : bool</span>
<span class="sd">            Whether to fail job on missing chunks</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set</span><span class="p">(</span><span class="n">failOnMissing</span><span class="o">=</span><span class="n">value</span><span class="p">)</span></div>

<div class="viewcode-block" id="Doc2Chunk.setLowerCase"><a class="viewcode-back" href="../../reference/autosummary/sparknlp.base.Doc2Chunk.html#sparknlp.base.Doc2Chunk.setLowerCase">[docs]</a>    <span class="k">def</span> <span class="nf">setLowerCase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets whether to lower case for matching case.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : bool</span>
<span class="sd">            Name of the Id Column</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set</span><span class="p">(</span><span class="n">lowerCase</span><span class="o">=</span><span class="n">value</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Chunk2Doc"><a class="viewcode-back" href="../../reference/autosummary/sparknlp.base.Chunk2Doc.html#sparknlp.base.Chunk2Doc">[docs]</a><span class="k">class</span> <span class="nc">Chunk2Doc</span><span class="p">(</span><span class="n">AnnotatorTransformer</span><span class="p">,</span> <span class="n">AnnotatorProperties</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Converts a ``CHUNK`` type column back into ``DOCUMENT``. Useful when</span>
<span class="sd">    trying to re-tokenize or do further analysis on a ``CHUNK`` result.</span>

<span class="sd">    For more extended examples on document pre-processing see the</span>
<span class="sd">    `Spark NLP Workshop &lt;https://github.com/JohnSnowLabs/spark-nlp-workshop/blob/master/tutorials/Certification_Trainings/Public/2.Text_Preprocessing_with_SparkNLP_Annotators_Transformers.ipynb&gt;`__.</span>

<span class="sd">    ====================== ======================</span>
<span class="sd">    Input Annotation types Output Annotation type</span>
<span class="sd">    ====================== ======================</span>
<span class="sd">    ``CHUNK``              ``DOCUMENT``</span>
<span class="sd">    ====================== ======================</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    None</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import sparknlp</span>
<span class="sd">    &gt;&gt;&gt; from sparknlp.base import *</span>
<span class="sd">    &gt;&gt;&gt; from sparknlp.pretrained import PretrainedPipeline</span>

<span class="sd">    Location entities are extracted and converted back into ``DOCUMENT`` type for</span>
<span class="sd">    further processing.</span>

<span class="sd">    &gt;&gt;&gt; data = spark.createDataFrame([[1, &quot;New York and New Jersey aren&#39;t that far apart actually.&quot;]]).toDF(&quot;id&quot;, &quot;text&quot;)</span>

<span class="sd">    Define pretrained pipeline that extracts Named Entities amongst other things</span>
<span class="sd">    and apply `Chunk2Doc` on it.</span>

<span class="sd">    &gt;&gt;&gt; pipeline = PretrainedPipeline(&quot;explain_document_dl&quot;)</span>
<span class="sd">    &gt;&gt;&gt; chunkToDoc = Chunk2Doc().setInputCols(&quot;entities&quot;).setOutputCol(&quot;chunkConverted&quot;)</span>
<span class="sd">    &gt;&gt;&gt; explainResult = pipeline.transform(data)</span>

<span class="sd">    Show results.</span>

<span class="sd">    &gt;&gt;&gt; result = chunkToDoc.transform(explainResult)</span>
<span class="sd">    &gt;&gt;&gt; result.selectExpr(&quot;explode(chunkConverted)&quot;).show(truncate=False)</span>
<span class="sd">    +------------------------------------------------------------------------------+</span>
<span class="sd">    |col                                                                           |</span>
<span class="sd">    +------------------------------------------------------------------------------+</span>
<span class="sd">    |[document, 0, 7, New York, [entity -&gt; LOC, sentence -&gt; 0, chunk -&gt; 0], []]    |</span>
<span class="sd">    |[document, 13, 22, New Jersey, [entity -&gt; LOC, sentence -&gt; 0, chunk -&gt; 1], []]|</span>
<span class="sd">    +------------------------------------------------------------------------------+</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    Doc2Chunk : for converting `DOCUMENT` annotations to `CHUNK`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Chunk2Doc&quot;</span>

    <span class="nd">@keyword_only</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Chunk2Doc</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">classname</span><span class="o">=</span><span class="s2">&quot;com.johnsnowlabs.nlp.Chunk2Doc&quot;</span><span class="p">)</span>

    <span class="nd">@keyword_only</span>
    <span class="k">def</span> <span class="nf">setParams</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_kwargs</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="Finisher"><a class="viewcode-back" href="../../reference/autosummary/sparknlp.base.Finisher.html#sparknlp.base.Finisher">[docs]</a><span class="k">class</span> <span class="nc">Finisher</span><span class="p">(</span><span class="n">AnnotatorTransformer</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Converts annotation results into a format that easier to use.</span>

<span class="sd">    It is useful to extract the results from Spark NLP Pipelines. The Finisher</span>
<span class="sd">    outputs annotation(s) values into ``String``.</span>

<span class="sd">    For more extended examples on document pre-processing see the</span>
<span class="sd">    `Spark NLP Workshop &lt;https://github.com/JohnSnowLabs/spark-nlp-workshop/blob/master/tutorials/Certification_Trainings/Public/2.Text_Preprocessing_with_SparkNLP_Annotators_Transformers.ipynb&gt;`__.</span>

<span class="sd">    ====================== ======================</span>
<span class="sd">    Input Annotation types Output Annotation type</span>
<span class="sd">    ====================== ======================</span>
<span class="sd">    ``ANY``                ``NONE``</span>
<span class="sd">    ====================== ======================</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    inputCols</span>
<span class="sd">        Input annotations</span>
<span class="sd">    outputCols</span>
<span class="sd">        Output finished annotation cols</span>
<span class="sd">    valueSplitSymbol</span>
<span class="sd">        Character separating values, by default #</span>
<span class="sd">    annotationSplitSymbol</span>
<span class="sd">        Character separating annotations, by default @</span>
<span class="sd">    cleanAnnotations</span>
<span class="sd">        Whether to remove annotation columns, by default True</span>
<span class="sd">    includeMetadata</span>
<span class="sd">        Whether to include annotation metadata, by default False</span>
<span class="sd">    outputAsArray</span>
<span class="sd">        Finisher generates an Array with the results instead of string, by</span>
<span class="sd">        default True</span>
<span class="sd">    parseEmbeddingsVectors</span>
<span class="sd">        Whether to include embeddings vectors in the process, by default False</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import sparknlp</span>
<span class="sd">    &gt;&gt;&gt; from sparknlp.base import *</span>
<span class="sd">    &gt;&gt;&gt; from sparknlp.annotator import *</span>
<span class="sd">    &gt;&gt;&gt; from sparknlp.pretrained import PretrainedPipeline</span>
<span class="sd">    &gt;&gt;&gt; data = spark.createDataFrame([[1, &quot;New York and New Jersey aren&#39;t that far apart actually.&quot;]]).toDF(&quot;id&quot;, &quot;text&quot;)</span>

<span class="sd">    Define pretrained pipeline that extracts Named Entities amongst other things</span>
<span class="sd">    and apply the `Finisher` on it.</span>

<span class="sd">    &gt;&gt;&gt; pipeline = PretrainedPipeline(&quot;explain_document_dl&quot;)</span>
<span class="sd">    &gt;&gt;&gt; finisher = Finisher().setInputCols(&quot;entities&quot;).setOutputCols(&quot;output&quot;)</span>
<span class="sd">    &gt;&gt;&gt; explainResult = pipeline.transform(data)</span>

<span class="sd">    Show results.</span>

<span class="sd">    &gt;&gt;&gt; explainResult.selectExpr(&quot;explode(entities)&quot;).show(truncate=False)</span>
<span class="sd">    +------------------------------------------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">    |entities                                                                                                                                              |</span>
<span class="sd">    +------------------------------------------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">    |[[chunk, 0, 7, New York, [entity -&gt; LOC, sentence -&gt; 0, chunk -&gt; 0], []], [chunk, 13, 22, New Jersey, [entity -&gt; LOC, sentence -&gt; 0, chunk -&gt; 1], []]]|</span>
<span class="sd">    +------------------------------------------------------------------------------------------------------------------------------------------------------+</span>
<span class="sd">    &gt;&gt;&gt; result = finisher.transform(explainResult)</span>
<span class="sd">    &gt;&gt;&gt; result.select(&quot;output&quot;).show(truncate=False)</span>
<span class="sd">    +----------------------+</span>
<span class="sd">    |output                |</span>
<span class="sd">    +----------------------+</span>
<span class="sd">    |[New York, New Jersey]|</span>
<span class="sd">    +----------------------+</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    Finisher : for finishing Strings</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">inputCols</span> <span class="o">=</span> <span class="n">Param</span><span class="p">(</span><span class="n">Params</span><span class="o">.</span><span class="n">_dummy</span><span class="p">(),</span> <span class="s2">&quot;inputCols&quot;</span><span class="p">,</span> <span class="s2">&quot;input annotations&quot;</span><span class="p">,</span> <span class="n">typeConverter</span><span class="o">=</span><span class="n">TypeConverters</span><span class="o">.</span><span class="n">toListString</span><span class="p">)</span>
    <span class="n">outputCols</span> <span class="o">=</span> <span class="n">Param</span><span class="p">(</span><span class="n">Params</span><span class="o">.</span><span class="n">_dummy</span><span class="p">(),</span> <span class="s2">&quot;outputCols&quot;</span><span class="p">,</span> <span class="s2">&quot;output finished annotation cols&quot;</span><span class="p">,</span> <span class="n">typeConverter</span><span class="o">=</span><span class="n">TypeConverters</span><span class="o">.</span><span class="n">toListString</span><span class="p">)</span>
    <span class="n">valueSplitSymbol</span> <span class="o">=</span> <span class="n">Param</span><span class="p">(</span><span class="n">Params</span><span class="o">.</span><span class="n">_dummy</span><span class="p">(),</span> <span class="s2">&quot;valueSplitSymbol&quot;</span><span class="p">,</span> <span class="s2">&quot;character separating annotations&quot;</span><span class="p">,</span> <span class="n">typeConverter</span><span class="o">=</span><span class="n">TypeConverters</span><span class="o">.</span><span class="n">toString</span><span class="p">)</span>
    <span class="n">annotationSplitSymbol</span> <span class="o">=</span> <span class="n">Param</span><span class="p">(</span><span class="n">Params</span><span class="o">.</span><span class="n">_dummy</span><span class="p">(),</span> <span class="s2">&quot;annotationSplitSymbol&quot;</span><span class="p">,</span> <span class="s2">&quot;character separating annotations&quot;</span><span class="p">,</span> <span class="n">typeConverter</span><span class="o">=</span><span class="n">TypeConverters</span><span class="o">.</span><span class="n">toString</span><span class="p">)</span>
    <span class="n">cleanAnnotations</span> <span class="o">=</span> <span class="n">Param</span><span class="p">(</span><span class="n">Params</span><span class="o">.</span><span class="n">_dummy</span><span class="p">(),</span> <span class="s2">&quot;cleanAnnotations&quot;</span><span class="p">,</span> <span class="s2">&quot;whether to remove annotation columns&quot;</span><span class="p">,</span> <span class="n">typeConverter</span><span class="o">=</span><span class="n">TypeConverters</span><span class="o">.</span><span class="n">toBoolean</span><span class="p">)</span>
    <span class="n">includeMetadata</span> <span class="o">=</span> <span class="n">Param</span><span class="p">(</span><span class="n">Params</span><span class="o">.</span><span class="n">_dummy</span><span class="p">(),</span> <span class="s2">&quot;includeMetadata&quot;</span><span class="p">,</span> <span class="s2">&quot;annotation metadata format&quot;</span><span class="p">,</span> <span class="n">typeConverter</span><span class="o">=</span><span class="n">TypeConverters</span><span class="o">.</span><span class="n">toBoolean</span><span class="p">)</span>
    <span class="n">outputAsArray</span> <span class="o">=</span> <span class="n">Param</span><span class="p">(</span><span class="n">Params</span><span class="o">.</span><span class="n">_dummy</span><span class="p">(),</span> <span class="s2">&quot;outputAsArray&quot;</span><span class="p">,</span> <span class="s2">&quot;finisher generates an Array with the results instead of string&quot;</span><span class="p">,</span> <span class="n">typeConverter</span><span class="o">=</span><span class="n">TypeConverters</span><span class="o">.</span><span class="n">toBoolean</span><span class="p">)</span>
    <span class="n">parseEmbeddingsVectors</span> <span class="o">=</span> <span class="n">Param</span><span class="p">(</span><span class="n">Params</span><span class="o">.</span><span class="n">_dummy</span><span class="p">(),</span> <span class="s2">&quot;parseEmbeddingsVectors&quot;</span><span class="p">,</span> <span class="s2">&quot;whether to include embeddings vectors in the process&quot;</span><span class="p">,</span> <span class="n">typeConverter</span><span class="o">=</span><span class="n">TypeConverters</span><span class="o">.</span><span class="n">toBoolean</span><span class="p">)</span>

    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Finisher&quot;</span>

    <span class="nd">@keyword_only</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Finisher</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">classname</span><span class="o">=</span><span class="s2">&quot;com.johnsnowlabs.nlp.Finisher&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setDefault</span><span class="p">(</span>
            <span class="n">cleanAnnotations</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">includeMetadata</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">outputAsArray</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">parseEmbeddingsVectors</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">valueSplitSymbol</span><span class="o">=</span><span class="s2">&quot;#&quot;</span><span class="p">,</span>
            <span class="n">annotationSplitSymbol</span><span class="o">=</span><span class="s2">&quot;@&quot;</span>
        <span class="p">)</span>

    <span class="nd">@keyword_only</span>
    <span class="k">def</span> <span class="nf">setParams</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_kwargs</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="Finisher.setInputCols"><a class="viewcode-back" href="../../reference/autosummary/sparknlp.base.Finisher.html#sparknlp.base.Finisher.setInputCols">[docs]</a>    <span class="k">def</span> <span class="nf">setInputCols</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets column names of input annotations.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        *value : str</span>
<span class="sd">            Input columns for the annotator</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set</span><span class="p">(</span><span class="n">inputCols</span><span class="o">=</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set</span><span class="p">(</span><span class="n">inputCols</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">value</span><span class="p">))</span></div>

<div class="viewcode-block" id="Finisher.setOutputCols"><a class="viewcode-back" href="../../reference/autosummary/sparknlp.base.Finisher.html#sparknlp.base.Finisher.setOutputCols">[docs]</a>    <span class="k">def</span> <span class="nf">setOutputCols</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets column names of finished output annotations.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        *value : List[str]</span>
<span class="sd">            List of output columns</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set</span><span class="p">(</span><span class="n">outputCols</span><span class="o">=</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set</span><span class="p">(</span><span class="n">outputCols</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">value</span><span class="p">))</span></div>

<div class="viewcode-block" id="Finisher.setValueSplitSymbol"><a class="viewcode-back" href="../../reference/autosummary/sparknlp.base.Finisher.html#sparknlp.base.Finisher.setValueSplitSymbol">[docs]</a>    <span class="k">def</span> <span class="nf">setValueSplitSymbol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets character separating values, by default #.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : str</span>
<span class="sd">            Character to separate annotations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set</span><span class="p">(</span><span class="n">valueSplitSymbol</span><span class="o">=</span><span class="n">value</span><span class="p">)</span></div>

<div class="viewcode-block" id="Finisher.setAnnotationSplitSymbol"><a class="viewcode-back" href="../../reference/autosummary/sparknlp.base.Finisher.html#sparknlp.base.Finisher.setAnnotationSplitSymbol">[docs]</a>    <span class="k">def</span> <span class="nf">setAnnotationSplitSymbol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets character separating annotations, by default @.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : str</span>
<span class="sd">            ...</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set</span><span class="p">(</span><span class="n">annotationSplitSymbol</span><span class="o">=</span><span class="n">value</span><span class="p">)</span></div>

<div class="viewcode-block" id="Finisher.setCleanAnnotations"><a class="viewcode-back" href="../../reference/autosummary/sparknlp.base.Finisher.html#sparknlp.base.Finisher.setCleanAnnotations">[docs]</a>    <span class="k">def</span> <span class="nf">setCleanAnnotations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets whether to remove annotation columns, by default True.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : bool</span>
<span class="sd">            Whether to remove annotation columns</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set</span><span class="p">(</span><span class="n">cleanAnnotations</span><span class="o">=</span><span class="n">value</span><span class="p">)</span></div>

<div class="viewcode-block" id="Finisher.setIncludeMetadata"><a class="viewcode-back" href="../../reference/autosummary/sparknlp.base.Finisher.html#sparknlp.base.Finisher.setIncludeMetadata">[docs]</a>    <span class="k">def</span> <span class="nf">setIncludeMetadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets whether to include annotation metadata.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : bool</span>
<span class="sd">            Whether to include annotation metadata</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set</span><span class="p">(</span><span class="n">includeMetadata</span><span class="o">=</span><span class="n">value</span><span class="p">)</span></div>

<div class="viewcode-block" id="Finisher.setOutputAsArray"><a class="viewcode-back" href="../../reference/autosummary/sparknlp.base.Finisher.html#sparknlp.base.Finisher.setOutputAsArray">[docs]</a>    <span class="k">def</span> <span class="nf">setOutputAsArray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets whether to generate an array with the results instead of a</span>
<span class="sd">        string.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : bool</span>
<span class="sd">            Whether to generate an array with the results instead of a string</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set</span><span class="p">(</span><span class="n">outputAsArray</span><span class="o">=</span><span class="n">value</span><span class="p">)</span></div>

<div class="viewcode-block" id="Finisher.setParseEmbeddingsVectors"><a class="viewcode-back" href="../../reference/autosummary/sparknlp.base.Finisher.html#sparknlp.base.Finisher.setParseEmbeddingsVectors">[docs]</a>    <span class="k">def</span> <span class="nf">setParseEmbeddingsVectors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets whether to include embeddings vectors in the process.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : bool</span>
<span class="sd">            Whether to include embeddings vectors in the process</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set</span><span class="p">(</span><span class="n">parseEmbeddingsVectors</span><span class="o">=</span><span class="n">value</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="EmbeddingsFinisher"><a class="viewcode-back" href="../../reference/autosummary/sparknlp.base.EmbeddingsFinisher.html#sparknlp.base.EmbeddingsFinisher">[docs]</a><span class="k">class</span> <span class="nc">EmbeddingsFinisher</span><span class="p">(</span><span class="n">AnnotatorTransformer</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Extracts embeddings from Annotations into a more easily usable form.</span>

<span class="sd">    This is useful for example:</span>

<span class="sd">    - WordEmbeddings,</span>
<span class="sd">    - Transformer based embeddings such as BertEmbeddings,</span>
<span class="sd">    - SentenceEmbeddings and</span>
<span class="sd">    - ChunkEmbeddings, etc.</span>

<span class="sd">    By using ``EmbeddingsFinisher`` you can easily transform your embeddings</span>
<span class="sd">    into array of floats or vectors which are compatible with Spark ML functions</span>
<span class="sd">    such as LDA, K-mean, Random Forest classifier or any other functions that</span>
<span class="sd">    require a ``featureCol``.</span>

<span class="sd">    For more extended examples see the</span>
<span class="sd">    `Spark NLP Workshop &lt;https://github.com/JohnSnowLabs/spark-nlp-workshop/blob/master/tutorials/Certification_Trainings/Public/5.1_Text_classification_examples_in_SparkML_SparkNLP.ipynb&gt;`__.</span>

<span class="sd">    ====================== ======================</span>
<span class="sd">    Input Annotation types Output Annotation type</span>
<span class="sd">    ====================== ======================</span>
<span class="sd">    ``EMBEDDINGS``         ``NONE``</span>
<span class="sd">    ====================== ======================</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    inputCols</span>
<span class="sd">        Names of input annotation columns containing embeddings</span>
<span class="sd">    outputCols</span>
<span class="sd">        Names of finished output columns</span>
<span class="sd">    cleanAnnotations</span>
<span class="sd">        Whether to remove all the existing annotation columns, by default False</span>
<span class="sd">    outputAsVector</span>
<span class="sd">        Whether to output the embeddings as Vectors instead of arrays,</span>
<span class="sd">        by default False</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    First extract embeddings.</span>

<span class="sd">    &gt;&gt;&gt; import sparknlp</span>
<span class="sd">    &gt;&gt;&gt; from sparknlp.base import *</span>
<span class="sd">    &gt;&gt;&gt; from sparknlp.annotator import *</span>
<span class="sd">    &gt;&gt;&gt; from pyspark.ml import Pipeline</span>
<span class="sd">    &gt;&gt;&gt; documentAssembler = DocumentAssembler() \\</span>
<span class="sd">    ...    .setInputCol(&quot;text&quot;) \\</span>
<span class="sd">    ...    .setOutputCol(&quot;document&quot;)</span>
<span class="sd">    &gt;&gt;&gt; tokenizer = Tokenizer() \\</span>
<span class="sd">    ...    .setInputCols(&quot;document&quot;) \\</span>
<span class="sd">    ...    .setOutputCol(&quot;token&quot;)</span>
<span class="sd">    &gt;&gt;&gt; normalizer = Normalizer() \\</span>
<span class="sd">    ...    .setInputCols(&quot;token&quot;) \\</span>
<span class="sd">    ...    .setOutputCol(&quot;normalized&quot;)</span>
<span class="sd">    &gt;&gt;&gt; stopwordsCleaner = StopWordsCleaner() \\</span>
<span class="sd">    ...    .setInputCols(&quot;normalized&quot;) \\</span>
<span class="sd">    ...    .setOutputCol(&quot;cleanTokens&quot;) \\</span>
<span class="sd">    ...    .setCaseSensitive(False)</span>
<span class="sd">    &gt;&gt;&gt; gloveEmbeddings = WordEmbeddingsModel.pretrained() \\</span>
<span class="sd">    ...    .setInputCols(&quot;document&quot;, &quot;cleanTokens&quot;) \\</span>
<span class="sd">    ...    .setOutputCol(&quot;embeddings&quot;) \\</span>
<span class="sd">    ...    .setCaseSensitive(False)</span>
<span class="sd">    &gt;&gt;&gt; embeddingsFinisher = EmbeddingsFinisher() \\</span>
<span class="sd">    ...    .setInputCols(&quot;embeddings&quot;) \\</span>
<span class="sd">    ...    .setOutputCols(&quot;finished_sentence_embeddings&quot;) \\</span>
<span class="sd">    ...    .setOutputAsVector(True) \\</span>
<span class="sd">    ...    .setCleanAnnotations(False)</span>
<span class="sd">    &gt;&gt;&gt; data = spark.createDataFrame([[&quot;Spark NLP is an open-source text processing library.&quot;]]) \\</span>
<span class="sd">    ...    .toDF(&quot;text&quot;)</span>
<span class="sd">    &gt;&gt;&gt; pipeline = Pipeline().setStages([</span>
<span class="sd">    ...    documentAssembler,</span>
<span class="sd">    ...    tokenizer,</span>
<span class="sd">    ...    normalizer,</span>
<span class="sd">    ...    stopwordsCleaner,</span>
<span class="sd">    ...    gloveEmbeddings,</span>
<span class="sd">    ...    embeddingsFinisher</span>
<span class="sd">    ... ]).fit(data)</span>
<span class="sd">    &gt;&gt;&gt; result = pipeline.transform(data)</span>

<span class="sd">    Show results.</span>

<span class="sd">    &gt;&gt;&gt; resultWithSize = result.selectExpr(&quot;explode(finished_sentence_embeddings) as embeddings&quot;)</span>
<span class="sd">    &gt;&gt;&gt; resultWithSize.show(5, 80)</span>
<span class="sd">    +--------------------------------------------------------------------------------+</span>
<span class="sd">    |                                                                      embeddings|</span>
<span class="sd">    +--------------------------------------------------------------------------------+</span>
<span class="sd">    |[0.1619900017976761,0.045552998781204224,-0.03229299932718277,-0.685609996318...|</span>
<span class="sd">    |[-0.42416998744010925,1.1378999948501587,-0.5717899799346924,-0.5078899860382...|</span>
<span class="sd">    |[0.08621499687433243,-0.15772999823093414,-0.06067200005054474,0.395359992980...|</span>
<span class="sd">    |[-0.4970499873161316,0.7164199948310852,0.40119001269340515,-0.05761000141501...|</span>
<span class="sd">    |[-0.08170200139284134,0.7159299850463867,-0.20677000284194946,0.0295659992843...|</span>
<span class="sd">    +--------------------------------------------------------------------------------+</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    EmbeddingsFinisher : for finishing embeddings</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">inputCols</span> <span class="o">=</span> <span class="n">Param</span><span class="p">(</span><span class="n">Params</span><span class="o">.</span><span class="n">_dummy</span><span class="p">(),</span> <span class="s2">&quot;inputCols&quot;</span><span class="p">,</span> <span class="s2">&quot;name of input annotation cols containing embeddings&quot;</span><span class="p">,</span> <span class="n">typeConverter</span><span class="o">=</span><span class="n">TypeConverters</span><span class="o">.</span><span class="n">toListString</span><span class="p">)</span>
    <span class="n">outputCols</span> <span class="o">=</span> <span class="n">Param</span><span class="p">(</span><span class="n">Params</span><span class="o">.</span><span class="n">_dummy</span><span class="p">(),</span> <span class="s2">&quot;outputCols&quot;</span><span class="p">,</span> <span class="s2">&quot;output EmbeddingsFinisher ouput cols&quot;</span><span class="p">,</span> <span class="n">typeConverter</span><span class="o">=</span><span class="n">TypeConverters</span><span class="o">.</span><span class="n">toListString</span><span class="p">)</span>
    <span class="n">cleanAnnotations</span> <span class="o">=</span> <span class="n">Param</span><span class="p">(</span><span class="n">Params</span><span class="o">.</span><span class="n">_dummy</span><span class="p">(),</span> <span class="s2">&quot;cleanAnnotations&quot;</span><span class="p">,</span> <span class="s2">&quot;whether to remove all the existing annotation columns&quot;</span><span class="p">,</span> <span class="n">typeConverter</span><span class="o">=</span><span class="n">TypeConverters</span><span class="o">.</span><span class="n">toBoolean</span><span class="p">)</span>
    <span class="n">outputAsVector</span> <span class="o">=</span> <span class="n">Param</span><span class="p">(</span><span class="n">Params</span><span class="o">.</span><span class="n">_dummy</span><span class="p">(),</span> <span class="s2">&quot;outputAsVector&quot;</span><span class="p">,</span> <span class="s2">&quot;if enabled it will output the embeddings as Vectors instead of arrays&quot;</span><span class="p">,</span> <span class="n">typeConverter</span><span class="o">=</span><span class="n">TypeConverters</span><span class="o">.</span><span class="n">toBoolean</span><span class="p">)</span>

    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;EmbeddingsFinisher&quot;</span>

    <span class="nd">@keyword_only</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">EmbeddingsFinisher</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">classname</span><span class="o">=</span><span class="s2">&quot;com.johnsnowlabs.nlp.EmbeddingsFinisher&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setDefault</span><span class="p">(</span>
            <span class="n">cleanAnnotations</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">outputAsVector</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>

    <span class="nd">@keyword_only</span>
    <span class="k">def</span> <span class="nf">setParams</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_kwargs</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="EmbeddingsFinisher.setInputCols"><a class="viewcode-back" href="../../reference/autosummary/sparknlp.base.EmbeddingsFinisher.html#sparknlp.base.EmbeddingsFinisher.setInputCols">[docs]</a>    <span class="k">def</span> <span class="nf">setInputCols</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets name of input annotation columns containing embeddings.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        *value : str</span>
<span class="sd">            Input columns for the annotator</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set</span><span class="p">(</span><span class="n">inputCols</span><span class="o">=</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set</span><span class="p">(</span><span class="n">inputCols</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">value</span><span class="p">))</span></div>

<div class="viewcode-block" id="EmbeddingsFinisher.setOutputCols"><a class="viewcode-back" href="../../reference/autosummary/sparknlp.base.EmbeddingsFinisher.html#sparknlp.base.EmbeddingsFinisher.setOutputCols">[docs]</a>    <span class="k">def</span> <span class="nf">setOutputCols</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets names of finished output columns.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        *value : List[str]</span>
<span class="sd">            Input columns for the annotator</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set</span><span class="p">(</span><span class="n">outputCols</span><span class="o">=</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set</span><span class="p">(</span><span class="n">outputCols</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">value</span><span class="p">))</span></div>

<div class="viewcode-block" id="EmbeddingsFinisher.setCleanAnnotations"><a class="viewcode-back" href="../../reference/autosummary/sparknlp.base.EmbeddingsFinisher.html#sparknlp.base.EmbeddingsFinisher.setCleanAnnotations">[docs]</a>    <span class="k">def</span> <span class="nf">setCleanAnnotations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets whether to remove all the existing annotation columns, by default</span>
<span class="sd">        False.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : bool</span>
<span class="sd">            Whether to remove all the existing annotation columns</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set</span><span class="p">(</span><span class="n">cleanAnnotations</span><span class="o">=</span><span class="n">value</span><span class="p">)</span></div>

<div class="viewcode-block" id="EmbeddingsFinisher.setOutputAsVector"><a class="viewcode-back" href="../../reference/autosummary/sparknlp.base.EmbeddingsFinisher.html#sparknlp.base.EmbeddingsFinisher.setOutputAsVector">[docs]</a>    <span class="k">def</span> <span class="nf">setOutputAsVector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets whether to output the embeddings as Vectors instead of arrays,</span>
<span class="sd">        by default False.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : bool</span>
<span class="sd">            Whether to output the embeddings as Vectors instead of arrays</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set</span><span class="p">(</span><span class="n">outputAsVector</span><span class="o">=</span><span class="n">value</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="GraphFinisher"><a class="viewcode-back" href="../../reference/autosummary/sparknlp.base.GraphFinisher.html#sparknlp.base.GraphFinisher">[docs]</a><span class="k">class</span> <span class="nc">GraphFinisher</span><span class="p">(</span><span class="n">AnnotatorTransformer</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper class to convert the knowledge graph from GraphExtraction into a</span>
<span class="sd">    generic format, such as RDF.</span>

<span class="sd">    ====================== ======================</span>
<span class="sd">    Input Annotation types Output Annotation type</span>
<span class="sd">    ====================== ======================</span>
<span class="sd">    ``NONE``               ``NONE``</span>
<span class="sd">    ====================== ======================</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    inputCol</span>
<span class="sd">        Name of input annotation column</span>
<span class="sd">    outputCol</span>
<span class="sd">        Name of finisher output column</span>
<span class="sd">    cleanAnnotations</span>
<span class="sd">        Whether to remove all the existing annotation columns, by default True</span>
<span class="sd">    outputAsArray</span>
<span class="sd">        Whether to generate an Array with the results, by default True</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    This is a continuation of the example of</span>
<span class="sd">    :class:`.GraphExtraction`. To see how the graph is extracted, see the</span>
<span class="sd">    documentation of that class.</span>

<span class="sd">    &gt;&gt;&gt; graphFinisher = GraphFinisher() \\</span>
<span class="sd">    ...     .setInputCol(&quot;graph&quot;) \\</span>
<span class="sd">    ...     .setOutputCol(&quot;graph_finished&quot;)</span>
<span class="sd">    ...     .setOutputAsArray(False)</span>
<span class="sd">    &gt;&gt;&gt; finishedResult = graphFinisher.transform(result)</span>
<span class="sd">    &gt;&gt;&gt; finishedResult.select(&quot;text&quot;, &quot;graph_finished&quot;).show(truncate=False)</span>
<span class="sd">    +-----------------------------------------------------+-----------------------------------------------------------------------+</span>
<span class="sd">    |text                                                 |graph_finished                                                         |</span>
<span class="sd">    +-----------------------------------------------------+-----------------------------------------------------------------------+</span>
<span class="sd">    |You and John prefer the morning flight through Denver|[[(prefer,nsubj,morning), (morning,flat,flight), (flight,flat,Denver)]]|</span>
<span class="sd">    +-----------------------------------------------------+-----------------------------------------------------------------------+</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">inputCol</span> <span class="o">=</span> <span class="n">Param</span><span class="p">(</span><span class="n">Params</span><span class="o">.</span><span class="n">_dummy</span><span class="p">(),</span> <span class="s2">&quot;inputCol&quot;</span><span class="p">,</span> <span class="s2">&quot;Name of input annotation col&quot;</span><span class="p">,</span> <span class="n">typeConverter</span><span class="o">=</span><span class="n">TypeConverters</span><span class="o">.</span><span class="n">toString</span><span class="p">)</span>
    <span class="n">outputCol</span> <span class="o">=</span> <span class="n">Param</span><span class="p">(</span><span class="n">Params</span><span class="o">.</span><span class="n">_dummy</span><span class="p">(),</span> <span class="s2">&quot;outputCol&quot;</span><span class="p">,</span> <span class="s2">&quot;Name of finisher output col&quot;</span><span class="p">,</span> <span class="n">typeConverter</span><span class="o">=</span><span class="n">TypeConverters</span><span class="o">.</span><span class="n">toString</span><span class="p">)</span>
    <span class="n">cleanAnnotations</span> <span class="o">=</span> <span class="n">Param</span><span class="p">(</span><span class="n">Params</span><span class="o">.</span><span class="n">_dummy</span><span class="p">(),</span>
                             <span class="s2">&quot;cleanAnnotations&quot;</span><span class="p">,</span>
                             <span class="s2">&quot;Whether to remove all the existing annotation columns&quot;</span><span class="p">,</span>
                             <span class="n">typeConverter</span><span class="o">=</span><span class="n">TypeConverters</span><span class="o">.</span><span class="n">toBoolean</span><span class="p">)</span>
    <span class="n">outputAsArray</span> <span class="o">=</span> <span class="n">Param</span><span class="p">(</span><span class="n">Params</span><span class="o">.</span><span class="n">_dummy</span><span class="p">(),</span> <span class="s2">&quot;outputAsArray&quot;</span><span class="p">,</span> <span class="s2">&quot;Finisher generates an Array with the results&quot;</span><span class="p">,</span>
                          <span class="n">typeConverter</span><span class="o">=</span><span class="n">TypeConverters</span><span class="o">.</span><span class="n">toBoolean</span><span class="p">)</span>

    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;GraphFinisher&quot;</span>

    <span class="nd">@keyword_only</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">GraphFinisher</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">classname</span><span class="o">=</span><span class="s2">&quot;com.johnsnowlabs.nlp.GraphFinisher&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setDefault</span><span class="p">(</span>
            <span class="n">cleanAnnotations</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">outputAsArray</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>

    <span class="nd">@keyword_only</span>
    <span class="k">def</span> <span class="nf">setParams</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_kwargs</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="GraphFinisher.setInputCol"><a class="viewcode-back" href="../../reference/autosummary/sparknlp.base.GraphFinisher.html#sparknlp.base.GraphFinisher.setInputCol">[docs]</a>    <span class="k">def</span> <span class="nf">setInputCol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets name of input annotation column.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : str</span>
<span class="sd">            Name of input annotation column.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set</span><span class="p">(</span><span class="n">inputCol</span><span class="o">=</span><span class="n">value</span><span class="p">)</span></div>

<div class="viewcode-block" id="GraphFinisher.setOutputCol"><a class="viewcode-back" href="../../reference/autosummary/sparknlp.base.GraphFinisher.html#sparknlp.base.GraphFinisher.setOutputCol">[docs]</a>    <span class="k">def</span> <span class="nf">setOutputCol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets name of finisher output column.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : str</span>
<span class="sd">            Name of finisher output column.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set</span><span class="p">(</span><span class="n">outputCol</span><span class="o">=</span><span class="n">value</span><span class="p">)</span></div>

<div class="viewcode-block" id="GraphFinisher.setCleanAnnotations"><a class="viewcode-back" href="../../reference/autosummary/sparknlp.base.GraphFinisher.html#sparknlp.base.GraphFinisher.setCleanAnnotations">[docs]</a>    <span class="k">def</span> <span class="nf">setCleanAnnotations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets whether to remove all the existing annotation columns, by</span>
<span class="sd">        default True.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : bool</span>
<span class="sd">            Whether to remove all the existing annotation columns, by default True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set</span><span class="p">(</span><span class="n">cleanAnnotations</span><span class="o">=</span><span class="n">value</span><span class="p">)</span></div>

<div class="viewcode-block" id="GraphFinisher.setOutputAsArray"><a class="viewcode-back" href="../../reference/autosummary/sparknlp.base.GraphFinisher.html#sparknlp.base.GraphFinisher.setOutputAsArray">[docs]</a>    <span class="k">def</span> <span class="nf">setOutputAsArray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets whether to generate an Array with the results, by default True.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : bool</span>
<span class="sd">            Whether to generate an Array with the results, by default True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set</span><span class="p">(</span><span class="n">outputAsArray</span><span class="o">=</span><span class="n">value</span><span class="p">)</span></div></div>

</pre></div>

              </div>
              
              
              <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
              
          </main>
          

      </div>
    </div>
  
  <script src="../../static/js/index.be7d3bbb2ef33a8344ce.js"></script>
<footer class="footer mt-5 mt-md-0">
  <div class="container">
    
    <div class="footer-item">
      <p class="copyright">
    &copy; Copyright 2021, John Snow Labs.<br>
</p>
    </div>
    
    <div class="footer-item">
      <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 4.3.0.<br>
</p>
    </div>
    
  </div>
</footer>
  </body>
</html>